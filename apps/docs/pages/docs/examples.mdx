import { BasicGrid, HorizontalGrid } from '@examples'
import { Tabs } from 'nextra/components'

# Examples

## Basic Grid

A simple responsive grid that adapts to container size:

<Tabs items={['preview', 'component', 'css']}>
  <Tabs.Tab>
    <BasicGrid />
  </Tabs.Tab>
  <Tabs.Tab>
```tsx
import { useVirtualGrid } from '@virtual-grid/lib'

const data = Array(1000).fill(0).map((_, i) => i + 1)

export function BasicGrid() {
  const { items, styles, gridRef, scrollRef } = useVirtualGrid({
    data,
    gap: 16,
    padding: [16, 16, 16, 16],
  })

  return (
    <div ref={scrollRef} className={classes.container}>
      <div
        ref={gridRef}
        style={styles}
        className={classes.grid}>
        {items?.map((item) => (
          <div key={item} className={classes.card}>
            {item}
          </div>
        ))}
      </div>
    </div>
  )
}
```
  </Tabs.Tab>
  <Tabs.Tab>
```css
.container {
  background: #000;
  border-radius: 6px;
  border: 1px solid #3f3f3f;
  height: 420px;
  overflow-y: auto;
}

.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  align-content: start;
  gap: 16px;
  padding: 16px;
}

.card {
  background: #191919;
  border-radius: 6px;
  font-size: 14px;
  height: 120px;
  white-space: nowrap;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  animation: fadeIn 0.5s forwards;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to   { opacity: 1; }
}

```
  </Tabs.Tab>
</Tabs>



## Horizontal Scrolling

Perfect for carousels and horizontal lists:

<Tabs items={['preview', 'component', 'css']}>
  <Tabs.Tab>
    <HorizontalGrid />
  </Tabs.Tab>
  <Tabs.Tab>
```tsx
import { useVirtualGrid } from '@virtual-grid/lib'

const data = Array(1000).fill(0).map((_, i) => i + 1)

export function HorizontalGrid() {
  const { items, styles, gridRef, scrollRef } = useVirtualGrid({
    data,
    gap: 16,
    padding: [16, 16, 16, 16],
    horizontal: true,
  })

  return (
    <div ref={scrollRef} className={classes.container}>
      <div
        ref={gridRef}
        style={styles}
        className={classes.grid}>
        {items?.map((item) => (
          <div key={item} className={classes.card}>
            {item}
          </div>
        ))}
      </div>
    </div>
  )
}
```
  </Tabs.Tab>
  <Tabs.Tab>
```css
.container {
  background: #000;
  border-radius: 6px;
  border: 1px solid #3f3f3f;
  overflow-y: hidden;
  overflow-x: auto;
}

.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  grid-template-rows: repeat(4, minmax(120px, 1fr));
  align-content: start;
  grid-auto-flow: column;
  gap: 16px;
  padding: 16px;
}

.card {
  background: #191919;
  border-radius: 6px;
  font-size: 14px;
  height: 100%;
  white-space: nowrap;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0;
  animation: fadeIn 0.5s forwards;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to   { opacity: 1; }
}
```
  </Tabs.Tab>
</Tabs>


## Carousel with Navigation

A carousel with previous/next controls and page indicators:

```tsx
function Carousel() {
  const data = Array(100).fill(0).map((_, i) => ({
    id: i,
    src: `https://picsum.photos/400/300?random=${i}`,
    title: `Slide ${i + 1}`
  }))

  const { items, styles, gridRef, scrollRef, page, onScrollTo } = useVirtualGrid({
    data,
    horizontal: true,
    gap: 16,
    padding: [0, 16, 0, 16],
  })

  const totalPages = Math.ceil(data.length / 3)

  return (
    <div className="carousel-container">
      <div
        ref={scrollRef}
        className="carousel-scroll"
        style={{ overflowX: 'auto', overflowY: 'hidden' }}>
        <div
          ref={gridRef}
          style={{
            ...styles,
            display: 'grid',
            gridAutoFlow: 'column',
            gridTemplateColumns: 'repeat(auto-fit, 400px)',
            gap: 16,
          }}>
          {items?.map((item) => (
            <div key={item.id} className="carousel-slide">
              <img src={item.src} alt={item.title} />
              <h3>{item.title}</h3>
            </div>
          ))}
        </div>
      </div>

      <div className="carousel-controls">
        <button
          onClick={() => onScrollTo(Math.max(0, (page ?? 0) - 1))}
          disabled={page === 0}>
          Previous
        </button>
        <span>{(page ?? 0) + 1} of {totalPages}</span>
        <button
          onClick={() => onScrollTo((page ?? 0) + 1)}
          disabled={(page ?? 0) >= totalPages - 1}>
          Next
        </button>
      </div>
    </div>
  )
}
```

## Programmatic Scrolling

Control scrolling programmatically with navigation buttons:

```tsx
function ScrollableGrid() {
  const data = Array(5000).fill(0).map((_, i) => ({ id: i, name: `Item ${i}` }))

  const { items, styles, gridRef, scrollRef, onScrollTo, page, pages } = useVirtualGrid({
    data,
    gap: 20,
    padding: [20, 20, 20, 20],
  })

  return (
    <div>
      <div className="navigation-controls">
        <button onClick={() => onScrollTo(0)}>First Page</button>
        <button
          onClick={() => onScrollTo((page ?? 0) - 1)}
          disabled={page === 0}>
          Previous
        </button>
        <span>Page {(page ?? 0) + 1} of {pages ?? 0}</span>
        <button
          onClick={() => onScrollTo((page ?? 0) + 1)}
          disabled={(page ?? 0) >= (pages ?? 0) - 1}>
          Next
        </button>
        <button onClick={() => onScrollTo((pages ?? 0) - 1)}>Last Page</button>
      </div>

      <div ref={scrollRef} style={{ height: '80vh', overflow: 'auto' }}>
        <div ref={gridRef} style={styles} className="grid">
          {items?.map((item) => (
            <div key={item.id} className="card">
              {item.name}
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}
```

## CSS Styling

Virtual Grid works with standard CSS Grid. The library handles the virtualization while you control the layout with CSS:

### Basic Responsive Grid

```css
.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  align-content: start;
}

.card {
  background: #f5f5f5;
  border-radius: 8px;
  padding: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 120px;
}
```

### Horizontal Layout

```css
.horizontal-grid {
  display: grid;
  grid-auto-flow: column;
  grid-template-columns: repeat(auto-fit, 200px);
  gap: 16px;
  height: 100%;
}

.horizontal-card {
  background: #f5f5f5;
  border-radius: 8px;
  padding: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
}
```

### Carousel Layout

```css
.carousel-container {
  position: relative;
}

.carousel-scroll {
  overflow-x: auto;
  overflow-y: hidden;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE and Edge */
}

.carousel-scroll::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
}

.carousel-slide {
  position: relative;
  border-radius: 8px;
  overflow: hidden;
}

.carousel-slide img {
  width: 100%;
  height: 250px;
  object-fit: cover;
}

.carousel-slide h3 {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  margin: 0;
  padding: 12px;
}

.carousel-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 16px;
}

.carousel-controls button {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  background: #007bff;
  color: white;
  cursor: pointer;
}

.carousel-controls button:disabled {
  background: #ccc;
  cursor: not-allowed;
}
```

### Fixed Columns Grid

```css
.fixed-columns {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
}

@media (max-width: 768px) {
  .fixed-columns {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 480px) {
  .fixed-columns {
    grid-template-columns: 1fr;
  }
}
```
## Error Handling

Virtual Grid follows a hooks-first approach and doesn't include built-in error boundaries. Implement error handling at the component level:

```tsx
interface SafeGridProps {
  data: any[]
}

function SafeGrid({ data }: SafeGridProps) {
  try {
    const virtualGrid = useVirtualGrid({ data })
    return <GridComponent {...virtualGrid} />
  } catch (error) {
    console.error('Virtual Grid Error:', error)
    // Fallback to non-virtualized grid
    return (
      <div className="fallback-grid">
        {data.map((item, index) => (
          <div key={index} className="card">
            {JSON.stringify(item)}
          </div>
        ))}
      </div>
    )
  }
}

// With error boundary
import { ErrorBoundary } from 'react-error-boundary'

function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div role="alert" className="error-container">
      <h2>Something went wrong with the grid:</h2>
      <pre>{error.message}</pre>
      <button onClick={resetErrorBoundary}>Try again</button>
    </div>
  )
}

function GridWithErrorBoundary({ data }) {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <SafeGrid data={data} />
    </ErrorBoundary>
  )
}
```

## Performance Tips

### Optimize Item Rendering

```tsx
// Memoize your item components
const ItemCard = React.memo(({ item }) => (
  <div className="card">
    <h3>{item.name}</h3>
    <p>{item.description}</p>
  </div>
))

// Use keys that don't change on re-renders
function OptimizedGrid({ data }) {
  const { items, styles, gridRef, scrollRef } = useVirtualGrid({ data })

  return (
    <div ref={scrollRef} style={{ height: '400px', overflow: 'auto' }}>
      <div ref={gridRef} style={styles}>
        {items?.map((item) => (
          <ItemCard key={item.id} item={item} />
        ))}
      </div>
    </div>
  )
}
```

### Adjust Off-screen Pages

```tsx
// For smooth scrolling with more memory usage
const smoothScrolling = useVirtualGrid({
  data,
  offScreenPages: 3
})

// For memory efficiency with less smooth scrolling
const memoryEfficient = useVirtualGrid({
  data,
  offScreenPages: 1
})
```
