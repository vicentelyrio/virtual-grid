import { Carousel } from '@examples'
import { Tabs } from 'nextra/components'

import VerticalGridDemo from '@examples/vertical-grid/vertical-grid.mdx'
import HorizontalGridDemo from '@examples/horizontal-grid/horizontal-grid.mdx'
import CarouselDemo from '@examples/carousel/carousel.mdx'

# Examples

<VerticalGridDemo />
<HorizontalGridDemo />
<CarouselDemo />

## Programmatic Scrolling

Control scrolling programmatically with navigation buttons:

```tsx
function ScrollableGrid() {
  const data = Array(5000).fill(0).map((_, i) => ({ id: i, name: `Item ${i}` }))

  const { items, styles, gridRef, scrollRef, onScrollTo, page, pages } = useVirtualGrid({
    data,
    gap: 20,
    padding: [20, 20, 20, 20],
  })

  return (
    <div>
      <div className="navigation-controls">
        <button onClick={() => onScrollTo(0)}>First Page</button>
        <button
          onClick={() => onScrollTo((page ?? 0) - 1)}
          disabled={page === 0}>
          Previous
        </button>
        <span>Page {(page ?? 0) + 1} of {pages ?? 0}</span>
        <button
          onClick={() => onScrollTo((page ?? 0) + 1)}
          disabled={(page ?? 0) >= (pages ?? 0) - 1}>
          Next
        </button>
        <button onClick={() => onScrollTo((pages ?? 0) - 1)}>Last Page</button>
      </div>

      <div ref={scrollRef} style={{ height: '80vh', overflow: 'auto' }}>
        <div ref={gridRef} style={styles} className="grid">
          {items?.map((item) => (
            <div key={item.id} className="card">
              {item.name}
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}
```

## CSS Styling

Virtual Grid works with standard CSS Grid. The library handles the virtualization while you control the layout with CSS:

### Basic Responsive Grid

```css
.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  align-content: start;
}

.card {
  background: #f5f5f5;
  border-radius: 8px;
  padding: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 120px;
}
```

### Horizontal Layout

```css
.horizontal-grid {
  display: grid;
  grid-auto-flow: column;
  grid-template-columns: repeat(auto-fit, 200px);
  gap: 16px;
  height: 100%;
}

.horizontal-card {
  background: #f5f5f5;
  border-radius: 8px;
  padding: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
}
```

### Carousel Layout

```css
.carousel-container {
  position: relative;
}

.carousel-scroll {
  overflow-x: auto;
  overflow-y: hidden;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE and Edge */
}

.carousel-scroll::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
}

.carousel-slide {
  position: relative;
  border-radius: 8px;
  overflow: hidden;
}

.carousel-slide img {
  width: 100%;
  height: 250px;
  object-fit: cover;
}

.carousel-slide h3 {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  margin: 0;
  padding: 12px;
}

.carousel-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 16px;
}

.carousel-controls button {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  background: #007bff;
  color: white;
  cursor: pointer;
}

.carousel-controls button:disabled {
  background: #ccc;
  cursor: not-allowed;
}
```

### Fixed Columns Grid

```css
.fixed-columns {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
}

@media (max-width: 768px) {
  .fixed-columns {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 480px) {
  .fixed-columns {
    grid-template-columns: 1fr;
  }
}
```
## Error Handling

Virtual Grid follows a hooks-first approach and doesn't include built-in error boundaries. Implement error handling at the component level:

```tsx
interface SafeGridProps {
  data: any[]
}

function SafeGrid({ data }: SafeGridProps) {
  try {
    const virtualGrid = useVirtualGrid({ data })
    return <GridComponent {...virtualGrid} />
  } catch (error) {
    console.error('Virtual Grid Error:', error)
    // Fallback to non-virtualized grid
    return (
      <div className="fallback-grid">
        {data.map((item, index) => (
          <div key={index} className="card">
            {JSON.stringify(item)}
          </div>
        ))}
      </div>
    )
  }
}

// With error boundary
import { ErrorBoundary } from 'react-error-boundary'

function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div role="alert" className="error-container">
      <h2>Something went wrong with the grid:</h2>
      <pre>{error.message}</pre>
      <button onClick={resetErrorBoundary}>Try again</button>
    </div>
  )
}

function GridWithErrorBoundary({ data }) {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <SafeGrid data={data} />
    </ErrorBoundary>
  )
}
```

## Performance Tips

### Optimize Item Rendering

```tsx
// Memoize your item components
const ItemCard = React.memo(({ item }) => (
  <div className="card">
    <h3>{item.name}</h3>
    <p>{item.description}</p>
  </div>
))

// Use keys that don't change on re-renders
function OptimizedGrid({ data }) {
  const { items, styles, gridRef, scrollRef } = useVirtualGrid({ data })

  return (
    <div ref={scrollRef} style={{ height: '400px', overflow: 'auto' }}>
      <div ref={gridRef} style={styles}>
        {items?.map((item) => (
          <ItemCard key={item.id} item={item} />
        ))}
      </div>
    </div>
  )
}
```

### Adjust Off-screen Pages

```tsx
// For smooth scrolling with more memory usage
const smoothScrolling = useVirtualGrid({
  data,
  offScreenPages: 3
})

// For memory efficiency with less smooth scrolling
const memoryEfficient = useVirtualGrid({
  data,
  offScreenPages: 1
})
```
