# Examples

## Basic Grid

A simple responsive grid that adapts to container size:

```tsx
import { useVirtualGrid } from '@virtual-grid/lib'

function BasicGrid() {
  const data = Array(10000).fill(0).map((_, i) => ({ id: i, name: `Item ${i}` }))

  const { items, styles, gridRef, scrollRef } = useVirtualGrid({
    data,
    gap: 16,
    padding: [16, 16, 16, 16],
  })

  return (
    <div ref={scrollRef} style={{ height: '400px', overflow: 'auto' }}>
      <div 
        ref={gridRef} 
        style={styles}
        className="grid"
      >
        {items?.map((item) => (
          <div key={item.id} className="card">
            {item.name}
          </div>
        ))}
      </div>
    </div>
  )
}
```

## Horizontal Scrolling

Perfect for carousels and horizontal lists:

```tsx
function HorizontalGrid() {
  const data = Array(100).fill(0).map((_, i) => ({ id: i, name: `Item ${i}` }))

  const { items, styles, gridRef, scrollRef } = useVirtualGrid({
    data,
    horizontal: true,
    gap: 12,
    padding: [0, 16, 0, 16],
  })

  return (
    <div 
      ref={scrollRef} 
      style={{ 
        width: '100%', 
        height: '200px',
        overflowX: 'auto', 
        overflowY: 'hidden' 
      }}
    >
      <div 
        ref={gridRef} 
        style={styles}
        className="horizontal-grid"
      >
        {items?.map((item) => (
          <div key={item.id} className="horizontal-card">
            {item.name}
          </div>
        ))}
      </div>
    </div>
  )
}
```

## Carousel with Navigation

A carousel with previous/next controls and page indicators:

```tsx
function Carousel() {
  const data = Array(100).fill(0).map((_, i) => ({
    id: i,
    src: `https://picsum.photos/400/300?random=${i}`,
    title: `Slide ${i + 1}`
  }))

  const { items, styles, gridRef, scrollRef, page, onScrollTo } = useVirtualGrid({
    data,
    horizontal: true,
    gap: 16,
    padding: [0, 16, 0, 16],
  })

  const totalPages = Math.ceil(data.length / 3)

  return (
    <div className="carousel-container">
      <div
        ref={scrollRef}
        className="carousel-scroll"
        style={{ overflowX: 'auto', overflowY: 'hidden' }}
      >
        <div
          ref={gridRef}
          style={{
            ...styles,
            display: 'grid',
            gridAutoFlow: 'column',
            gridTemplateColumns: 'repeat(auto-fit, 400px)',
            gap: 16,
          }}
        >
          {items?.map((item) => (
            <div key={item.id} className="carousel-slide">
              <img src={item.src} alt={item.title} />
              <h3>{item.title}</h3>
            </div>
          ))}
        </div>
      </div>

      <div className="carousel-controls">
        <button 
          onClick={() => onScrollTo(Math.max(0, (page ?? 0) - 1))}
          disabled={page === 0}
        >
          Previous
        </button>
        <span>{(page ?? 0) + 1} of {totalPages}</span>
        <button 
          onClick={() => onScrollTo((page ?? 0) + 1)}
          disabled={(page ?? 0) >= totalPages - 1}
        >
          Next
        </button>
      </div>
    </div>
  )
}
```

## Programmatic Scrolling

Control scrolling programmatically with navigation buttons:

```tsx
function ScrollableGrid() {
  const data = Array(5000).fill(0).map((_, i) => ({ id: i, name: `Item ${i}` }))

  const { items, styles, gridRef, scrollRef, onScrollTo, page, pages } = useVirtualGrid({
    data,
    gap: 20,
    padding: [20, 20, 20, 20],
  })

  return (
    <div>
      <div className="navigation-controls">
        <button onClick={() => onScrollTo(0)}>First Page</button>
        <button 
          onClick={() => onScrollTo((page ?? 0) - 1)}
          disabled={page === 0}
        >
          Previous
        </button>
        <span>Page {(page ?? 0) + 1} of {pages ?? 0}</span>
        <button 
          onClick={() => onScrollTo((page ?? 0) + 1)}
          disabled={(page ?? 0) >= (pages ?? 0) - 1}
        >
          Next
        </button>
        <button onClick={() => onScrollTo((pages ?? 0) - 1)}>Last Page</button>
      </div>

      <div ref={scrollRef} style={{ height: '80vh', overflow: 'auto' }}>
        <div ref={gridRef} style={styles} className="grid">
          {items?.map((item) => (
            <div key={item.id} className="card">
              {item.name}
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}
```

## CSS Styling

Virtual Grid works with standard CSS Grid. The library handles the virtualization while you control the layout with CSS:

### Basic Responsive Grid

```css
.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 20px;
  align-content: start;
}

.card {
  background: #f5f5f5;
  border-radius: 8px;
  padding: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  min-height: 120px;
}
```

### Horizontal Layout

```css
.horizontal-grid {
  display: grid;
  grid-auto-flow: column;
  grid-template-columns: repeat(auto-fit, 200px);
  gap: 16px;
  height: 100%;
}

.horizontal-card {
  background: #f5f5f5;
  border-radius: 8px;
  padding: 16px;
  display: flex;
  align-items: center;
  justify-content: center;
}
```

### Carousel Layout

```css
.carousel-container {
  position: relative;
}

.carousel-scroll {
  overflow-x: auto;
  overflow-y: hidden;
  scrollbar-width: none; /* Firefox */
  -ms-overflow-style: none; /* IE and Edge */
}

.carousel-scroll::-webkit-scrollbar {
  display: none; /* Chrome, Safari, Opera */
}

.carousel-slide {
  position: relative;
  border-radius: 8px;
  overflow: hidden;
}

.carousel-slide img {
  width: 100%;
  height: 250px;
  object-fit: cover;
}

.carousel-slide h3 {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: rgba(0, 0, 0, 0.7);
  color: white;
  margin: 0;
  padding: 12px;
}

.carousel-controls {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-top: 16px;
}

.carousel-controls button {
  padding: 8px 16px;
  border: none;
  border-radius: 4px;
  background: #007bff;
  color: white;
  cursor: pointer;
}

.carousel-controls button:disabled {
  background: #ccc;
  cursor: not-allowed;
}
```

### Fixed Columns Grid

```css
.fixed-columns {
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 16px;
}

@media (max-width: 768px) {
  .fixed-columns {
    grid-template-columns: repeat(2, 1fr);
  }
}

@media (max-width: 480px) {
  .fixed-columns {
    grid-template-columns: 1fr;
  }
}
```

## Accessibility

Virtual Grid provides the core virtualization logic while leaving accessibility implementation to your components:

```tsx
function AccessibleGrid() {
  const data = Array(1000).fill(0).map((_, i) => ({ 
    id: i, 
    name: `Item ${i}`,
    description: `Description for item ${i}`
  }))

  const { items, styles, gridRef, scrollRef, columns } = useVirtualGrid({ 
    data,
    gap: 16,
    padding: [16, 16, 16, 16]
  })

  return (
    <div
      ref={scrollRef}
      role="grid"
      aria-label="Virtual data grid"
      aria-rowcount={columns ? Math.ceil(data.length / columns) : undefined}
      aria-colcount={columns}
      tabIndex={0}
      style={{ height: '400px', overflow: 'auto' }}
    >
      <div ref={gridRef} style={styles}>
        {items?.map((item, index) => (
          <div
            key={item.id}
            role="gridcell"
            tabIndex={-1}
            aria-rowindex={columns ? Math.floor(index / columns) + 1 : undefined}
            aria-colindex={columns ? (index % columns) + 1 : undefined}
            aria-label={`${item.name}, ${item.description}`}
            className="accessible-card"
          >
            <h3>{item.name}</h3>
            <p>{item.description}</p>
          </div>
        ))}
      </div>
    </div>
  )
}
```

## Error Handling

Virtual Grid follows a hooks-first approach and doesn't include built-in error boundaries. Implement error handling at the component level:

```tsx
interface SafeGridProps {
  data: any[]
}

function SafeGrid({ data }: SafeGridProps) {
  try {
    const virtualGrid = useVirtualGrid({ data })
    return <GridComponent {...virtualGrid} />
  } catch (error) {
    console.error('Virtual Grid Error:', error)
    // Fallback to non-virtualized grid
    return (
      <div className="fallback-grid">
        {data.map((item, index) => (
          <div key={index} className="card">
            {JSON.stringify(item)}
          </div>
        ))}
      </div>
    )
  }
}

// With error boundary
import { ErrorBoundary } from 'react-error-boundary'

function ErrorFallback({ error, resetErrorBoundary }) {
  return (
    <div role="alert" className="error-container">
      <h2>Something went wrong with the grid:</h2>
      <pre>{error.message}</pre>
      <button onClick={resetErrorBoundary}>Try again</button>
    </div>
  )
}

function GridWithErrorBoundary({ data }) {
  return (
    <ErrorBoundary FallbackComponent={ErrorFallback}>
      <SafeGrid data={data} />
    </ErrorBoundary>
  )
}
```

## Performance Tips

### Optimize Item Rendering

```tsx
// Memoize your item components
const ItemCard = React.memo(({ item }) => (
  <div className="card">
    <h3>{item.name}</h3>
    <p>{item.description}</p>
  </div>
))

// Use keys that don't change on re-renders
function OptimizedGrid({ data }) {
  const { items, styles, gridRef, scrollRef } = useVirtualGrid({ data })

  return (
    <div ref={scrollRef} style={{ height: '400px', overflow: 'auto' }}>
      <div ref={gridRef} style={styles}>
        {items?.map((item) => (
          <ItemCard key={item.id} item={item} />
        ))}
      </div>
    </div>
  )
}
```

### Adjust Off-screen Pages

```tsx
// For smooth scrolling with more memory usage
const smoothScrolling = useVirtualGrid({ 
  data, 
  offScreenPages: 3 
})

// For memory efficiency with less smooth scrolling
const memoryEfficient = useVirtualGrid({ 
  data, 
  offScreenPages: 1 
})
```
